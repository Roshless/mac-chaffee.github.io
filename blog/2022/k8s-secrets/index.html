<!DOCTYPE html>
<html lang="en">
    <head>
        
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta name="description" content="Mac Chaffee&#x27;s tech blog">
        

        <title>Mac Chaffee</title>

        

<meta name="image" content="https://www.macchaffee.com/static/favicon.png">
<meta property="og:image" content="https://www.macchaffee.com/static/favicon.png">
<meta name="theme-color" content="#ECEBF3">
<link rel="shortcut icon" href="/static/favicon.png" type="image/png">

<meta property="og:title" content="Plain Kubernetes secrets are fine">

<meta property="og:description" content="Mac Chaffee&#x27;s tech blog">

<link rel="stylesheet" href="/blog/theme.css">
<style>
body {
    font: 400 18px/1.6 "Helvetica Neue", Helvetica, Arial, sans-serif;
}
h1 {
    font-size: 47px;
}
ul {
    list-style-type: disc;
}
code {
    font-family: monospace;
    padding: 1px 5px;
    font-size: 18px;
    background-color: #101a20;
}
.search-box {
    background-color: #101a20;
    border: 2px solid #36596c;
    font-size: 20px;
    line-height: 2;
    color: #c0c5ce;
    margin-top: 10px;
}
</style>

        
    </head>
    <body>
        <div class="content">
        
        
            <header>
                <div class="header-left">
                    <a href="&#x2F;blog" class="logo">Mac Chaffee</a>
                </div>
                <div class="header-right">
                    <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                        
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="/blog/2022/">
                                    <span itemprop="name">2022</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="/blog/2021/">
                                    <span itemprop="name">2021</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="/blog/2020/">
                                    <span itemprop="name">2020</span>
                                </a>
                            </li>
                        
                        
                        <li class="nav">
                            <a itemprop="url" href="https://github.com/mac-chaffee">
                                <img class="icon" src="&#x2F;blog/icons/github.svg" alt="Github">
                            </a>
                        </li>
                        
                        
                    </nav>
                </div>
            </header>
        
        
        <main>
            
<article itemscope itemtype="http://schema.org/BlogPosting">
    <div itemprop="headline">
        <h1>Plain Kubernetes secrets are fine</h1>
        <div class="border"></div>
        <time datetime="2022-04-30" class="date" itemprop="datePublished">
            30 Apr 2022
        </time>
    </div>
    <div itemprop="articleBody">
        <p>It's no secret that Kubernetes Secrets are just base64-encoded strings stored in etcd alongside the rest of the cluster's state. Ever since the <a href="https://github.com/kubernetes/kubernetes/pull/4514">introduction of Secrets in 2015</a>, armchair security experts have been scoffing at this decision and seeking alternatives. I think those people are missing the point.</p>
<p>The design of the Secrets API dates back to before Kubernetes v0.12. In the <a href="https://github.com/kubernetes/kubernetes/issues/2030#issuecomment-61584588">a thread the predates the original design document</a>, there's a line that hints at why people might be confused by Secrets:</p>
<blockquote>
<p>Its hard to evaluate these alternatives without a threat model</p>
</blockquote>
<p>That's exactly the issue. The naive approach to securing software is to blindly implement a checklist of security features. But a deeper understanding of security will quickly uncover that perfect security is impossible; you have to make trade-offs and prioritize the most likely scenarios. Creating a <a href="https://owasp.org/www-community/Threat_Modeling_Process">threat model</a> can help you make those decisions. Let's create a rudimentary threat model for Kubernetes Secrets and see what comes up.</p>
<h2 id="a-simple-threat-model-for-kubernetes-secrets">A simple threat model for Kubernetes Secrets</h2>
<h4 id="what-are-we-protecting">What are we protecting?</h4>
<p>Secrets are generally used to store things like database passwords and private keys meaning they are a high-value target.</p>
<h4 id="what-does-a-security-failure-look-like">What does a security failure look like?</h4>
<p>If an attacker is able to read a secret, they can use it to perform further attacks such as stealing data, modifying/deleting/ransoming data, or gaining authorization to do things like spawn pods that mine crypto. Normally we'd use something like <a href="https://wiki.openstack.org/wiki/Security/OSSA-Metrics#DREAD">DREAD</a> to rank the severity of different attacks, but exposing secrets is somewhat binary unless we have a specific secret in mind.</p>
<h4 id="how-can-secrets-be-stolen-what-can-go-wrong">How can secrets be stolen (what can go wrong)?</h4>
<p>At a bare minimum, secrets need to exist in plaintext in the memory of whatever application needs it, where it can (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=72101855fb9a2b3cd72c051791609a217c4a6281">almost</a>) <a href="https://github.com/n1nj4sec/mimipy">always</a> be stolen by another process on the same node with enough perseverance.</p>
<p>We also need to store the secret somewhere persistent. In our case, secrets are stored inside etcd and accessible from the Kubernetes API. This copy of secrets can be stolen in any of the following ways:</p>
<ol>
<li>Root access to a control plane node (read etcd's memory, read the on-disk dump, or steal a client cert and connect directly)</li>
<li>Root access to a worker node (steal kubelet's client cert and read the secret from the API server, or read the secret file/env var directly)</li>
<li>Access to the physical storage of a control plane node (plug the hard drive into another computer and read the etcd data)</li>
<li>Broken RBAC (a <a href="https://github.com/kubernetes/ingress-nginx/issues/7837">stolen service account token</a> or an overly-permissive role)</li>
</ol>
<h4 id="how-can-we-prevent-those-attacks">How can we prevent those attacks?</h4>
<p>Stealing secrets from memory is a risk we're forced to tolerate. Applications could use auto-expiring tokens or multi-factor authentication, but those features are out of scope since they are application-dependent.</p>
<p>Root access to nodes is a huge concern. This can be mitigated by general server hardening, patching, and <a href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">preventing privileged pods from running</a>, but this is probably the most complex threat to address.</p>
<p>Access to physical storage can be mitigated by encrypting disks at rest (and notably: storing the encryption key in a separate security domain).</p>
<p>Broken RBAC is tough, but calling them &quot;Secrets&quot; means that users are more likely to keep an eye on Roles/ClusterRoles that grant access to &quot;get&quot; &quot;secrets&quot;, and special auditing can be placed on them.</p>
<h2 id="takeaways-from-the-threat-model">Takeaways from the threat model</h2>
<p>The threat model exposes an inconvenient truth that storing secrets is hard since the plaintext version has to exist somewhere (in contrast to e.g. password hashes). That's just the problem with reversible encryption.</p>
<p>Any improvement on the current Secrets implementation would have to mitigate more of those attacks, but I posit that <em>for most use-cases</em>, a better implementation does not exist.</p>
<h2 id="alternatives-to-kubernetes-secrets">Alternatives to Kubernetes Secrets</h2>
<p>Let's looks at some of the alternatives that exist and see how they measure up.</p>
<h4 id="etcd-encryption-at-rest">Etcd encryption at rest</h4>
<p>I'm shocked this is still the <a href="https://kubernetes.io/docs/concepts/configuration/secret/#alternatives-to-secrets">#1 recommended alternative</a> considering how wildly useless it is.</p>
<p><a href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/">Etcd encryption at rest</a> involves encrypting all Secrets inside etcd with a key that is... on the same filesystem as etcd itself. So <em>no</em> additional attacks in our threat model are mitigated here. Not even the &quot;physical access&quot; attack since the key is stored on the same disk! Or at least another disk that is accessible from the same host (not even an option mentioned in the docs).</p>
<h4 id="etcd-encryption-via-kms">Etcd encryption via KMS</h4>
<p>You can replace your encryption key from the above method with a <a href="https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/">Key Management Service from your favorite cloud provider</a>.</p>
<p>While this is listed as the &quot;Strongest&quot; method, it's basically just as insecure according to our threat model. An attacker who can access the node can just mimic what etcd does and decrypt the secrets before exfiltrating them. At least this mitigates physical access to the disk, if and only if the KMS client is authenticating to your cloud provider with an auto-rotating, multi-factor token.</p>
<p>Using this option requires a hard dependency on your cloud provider, a lot of complexity, and a BIG blast radius if it ever breaks. If you're forced to encrypt &quot;secrets&quot; at rest for compliance, this is unfortunately your best option despite it not really benefitting your security posture.</p>
<h4 id="vault-sidecar-injector">Vault Sidecar Injector</h4>
<p>Here's the big one people point to. At its core, Vault is just a key-value store with a few key features:</p>
<ol>
<li>A clever <a href="https://www.vaultproject.io/docs/concepts/seal">Shamir sealing process</a>, which people immediately disable in favor of <a href="https://www.vaultproject.io/docs/concepts/seal#auto-unseal">auto-unsealing</a> which negates the benefits of sealing just like etcd encryption via KMS.</li>
<li>A rich policy language, which few people bother to learn.</li>
<li>Great auditing, which no one monitors.</li>
</ol>
<p>So in the end, Vault is just a key-value store unless you're paying $$$ for a managed Vault instance or a team of in-house Vault experts. I've worked for a company where we had a whole team running HSM-backed Enterprise Vault, but that thing still went down all the time.</p>
<p>But let's say you have the deep pockets for an impossibly-well-maintained Vault instance. You've just installed the <a href="https://www.vaultproject.io/docs/platform/k8s/injector">Vault Sidecar Injector</a> in your Kubernetes cluster. Do you get <em>any</em> additional security out of this arrangement? I'd argue no.</p>
<p>The sidecar injector works by modifying pods to have a Vault client sidecar which authenticates to your Vault server, downloads the secret, and stores it in a shared-memory volume which your app can access like a regular file.</p>
<p>If an attacker hacks any node (worker or control plane), they can run any pod with the vault annotations and steal the secrets.</p>
<p>If someone accesses the physical disk of a node, they can't get the secrets directly, but they can get vault credentials (tied to the serviceaccount) and steal the secrets that way. I think regular Vault credentials are time-based and can be made multi-factor, so technically we could say vault prevents this one attack.</p>
<p>So according to our threat model, using Vault introduces a few layers of indirection, but ultimately does not protect secrets much better than plain Kubernetes Secrets. Just using encrypted disks and storing the key somewhere safe would provide the same level of security MUCH more simply and cheaply.</p>
<h2 id="conclusion">Conclusion</h2>
<p>By creating a threat model that includes the kinds of attacks you want to mitigate, it's clear that managing secrets safely is extremely difficult. The problem is NOT that secrets are just base64 encoded; that was never meant as a security feature. And the problem cannot be simply waved away by software/cloud providers and their flashy documentation.</p>
<p>For something as security-sensitive and difficult as storing secret, start with a threat model. If multiple solutions have similar security according to the threat model, pick the simpler one to reduce the overall attack surface.</p>

    </div>
</article>

        </main>
        
        <footer>
            
    <div class="border"></div>
    <div class="footer">
        
        <div>
            <a href="/">Home</a>
        </div>
    </div>

        </footer>
    
        </div>
    </body>
</html>
